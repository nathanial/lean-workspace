<p>Canopy is Afferent's reactive widget system built on the <code>reactive</code> FRP library. It provides
hooks, dynamic rendering, and event wiring for building interactive applications with declarative,
composable components.</p>

<h3>Monad Stack</h3>

<pre><code class="language-lean">WidgetM α = StateT WidgetMState ReactiveM α   -- Accumulates widget renders
ReactiveM α = ReaderT ReactiveEvents SpiderM α -- Carries event context
SpiderM α ≈ IO α                               -- Reactive runtime</code></pre>

<ul>
  <li><strong>WidgetM</strong> - Build widget trees, emit renders, use hooks</li>
  <li><strong>ReactiveM</strong> - Access event streams, create subscriptions</li>
  <li><strong>SpiderM</strong> - Execute IO, run reactive network</li>
</ul>

<h3>Core FRP Types</h3>

<pre><code class="language-lean">-- Discrete occurrences (push-based)
Event Spider α       -- Fires values to subscribers

-- Time-varying values (pull-based)
Behavior Spider α    -- Sampable at any time

-- Behavior + change notification
Dynamic Spider α     -- .current : Behavior, .updated : Event, .sample : IO α</code></pre>

<h3>Component Hooks</h3>

<p>Hooks access event streams from the reactive context:</p>

<pre><code class="language-lean">-- Hover state for a named widget
useHover : String → ReactiveM (Dynamic Spider Bool)

-- Click event for a named widget
useClick : String → ReactiveM (Event Spider Unit)

-- Click with position data (for sliders)
useClickData : String → ReactiveM (Event Spider ClickData)

-- Shared elapsed time (continuous animations)
useElapsedTime : ReactiveM (Dynamic Spider Float)

-- Animation frames with delta time (physics, delays)
useAnimationFrame : ReactiveM (Event Spider Float)

-- Keyboard events
useKeyboard : ReactiveM (Event Spider KeyData)

-- All clicks (for focus management)
useAllClicks : ReactiveM (Event Spider ClickData)</code></pre>

<h3>Key Combinators</h3>

<pre><code class="language-lean">-- Create dynamic from initial value + update event
holdDyn : α → Event Spider α → m (Dynamic Spider α)

-- Fold over events (like Redux reducer)
foldDyn : (α → β → β) → β → Event Spider α → m (Dynamic Spider β)

-- Transform events
Event.map : (α → β) → Event Spider α → Event Spider β
Event.filter : (α → Bool) → Event Spider α → Event Spider α

-- Merge events (leftmost wins on simultaneous)
Event.leftmost : List (Event Spider α) → m (Event Spider α)

-- Execute IO effects when event fires
performEvent_ : Event Spider (IO Unit) → m Unit</code></pre>

<h3>Dynamic Widget Rendering</h3>

<p><strong>Important:</strong> Never use <code>sample</code> in Canopy widgets. Use <code>dynWidget</code> instead:</p>

<pre><code class="language-lean">-- BAD: Sampling breaks reactivity
emit do
  let value ← someDynamic.sample  -- DON'T DO THIS
  pure (someVisual value)

-- GOOD: dynWidget rebuilds when the dynamic changes
let _ ← dynWidget someDynamic fun value => do
  emit do pure (someVisual value)</code></pre>

<h3>Container Combinators</h3>

<pre><code class="language-lean">-- Layout containers
column' (gap : Float) (style : BoxStyle) (children : WidgetM α) : WidgetM α
row' (gap : Float) (style : BoxStyle) (children : WidgetM α) : WidgetM α
flexRow' (props : FlexContainer) (style : BoxStyle) (children : WidgetM α) : WidgetM α
flexColumn' (props : FlexContainer) (style : BoxStyle) (children : WidgetM α) : WidgetM α

-- Panel containers
titledPanel' (title : String) (variant : PanelVariant) (theme : Theme) (children : WidgetM α) : WidgetM α
elevatedPanel' (theme : Theme) (padding : Float) (children : WidgetM α) : WidgetM α
outlinedPanel' (theme : Theme) (padding : Float) (children : WidgetM α) : WidgetM α</code></pre>

<h3>Click Counter Example</h3>

<pre><code class="language-lean">def clickCounterPanel (theme : Theme) : WidgetM Unit :=
  titledPanel' "Click Counter" .outlined theme do
    caption' "Button displays its own click count:" theme
    -- Register widget for event handling
    let name ← registerComponentW "counter-button"
    let isHovered ← useHover name
    let onClick ← useClick name
    -- Count clicks using foldDyn
    let clickCount ← foldDyn (fun _ n => n + 1) 0 onClick
    -- Combine dynamics and rebuild button when either changes
    let buttonState ← Dynamic.zipWithM (fun count hovered => (count, hovered)) clickCount isHovered
    let _ ← dynWidget buttonState fun (count, hovered) => do
      let state := { hovered, pressed := false, focused := false }
      let label := if count == 0 then "Click me!" else s!"Clicked {count} times"
      emit do pure (buttonVisual name label theme .primary state)</code></pre>

<h3>Cross-Tree Wiring</h3>

<p>For wiring between components in different parts of the tree, create trigger events before building the widget tree:</p>

<pre><code class="language-lean">-- Pre-create shared trigger (outside runWidget)
let (clickTrigger, fireClick) ← newTriggerEvent (t := Spider) (a := Unit)
let clickCount ← foldDyn (fun _ n => n + 1) 0 clickTrigger

let (_, render) ← runWidget do
  -- Display updates reactively when clickCount changes
  let _ ← dynWidget clickCount fun count => do
    caption' s!"Clicks: {count}" theme

  -- Button (fires trigger)
  let click ← button "Click Me" theme .primary
  performEvent_ (← Event.mapM (fun _ => fireClick ()) click)</code></pre>

<h3>Conditional Rendering</h3>

<pre><code class="language-lean">-- Show/hide based on dynamic bool
when' : Dynamic Spider Bool → WidgetM Unit → WidgetM Unit

-- Example
let isExpanded ← holdDyn false toggleEvent
when' isExpanded do
  column' (gap := 8) (style := {}) do
    bodyText' "This content is conditionally shown" theme</code></pre>
